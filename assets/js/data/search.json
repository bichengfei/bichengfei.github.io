[ { "title": "Springboot动态多数据源", "url": "/posts/SpringBoot%E5%8A%A8%E6%80%81%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90/", "categories": "", "tags": "", "date": "2023-07-03 00:00:00 +0800", "snippet": "title: Spring Boot 动态多数据源author: BiChengfeidate: 2023-07-03 14:53:00 +0800categories: [JAVA]tags: [JAVA, Spring Boot, MySQL]pin: truehttps://github.com/bichengfei/dynamic-ds 把租户唯一标识存储在ThreadLocal中，然后实现javax.sql.DataSource，重写getConnection方法，使得不同租户，获取不同的数据库连接 在新增租户的时候，JPA 可以自动生成表结构 " }, { "title": "shell", "url": "/posts/shell/", "categories": "shell", "tags": "shell", "date": "2021-12-29 15:53:00 +0800", "snippet": " 自定义命令 bichengfeideMacBook-Pro:~ bichengfei$ cdbichengfeideMacBook-Pro:~ bichengfei$ pwd/Users/bichengfeibichengfeideMacBook-Pro:~ bichengfei$ vi .bash_profile#····编辑文件···bichengfeideMacBook-Pro:~ bichengfei$ cat .bash_profile | grep aliasalias ll=&#39;ls -lF&#39;bichengfeideMacBook-Pro:~..." }, { "title": "单点登录", "url": "/posts/%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95/", "categories": "SSO", "tags": "SSO", "date": "2021-12-06 00:00:00 +0800", "snippet": " 访问站点 A 1.1 已登录，正常访问 1.2 未登录，跳转到 SSO 站点，url 中带 A 站点回调地址 URL_A ​ 1.2.1 SSO 站点已登录，调用 URL_A?token=xxxxx ​ 1.2.2 SSO 站点未登录，输入用户名、密码登录 SSO 站点，调用 URL_A?token=xxxxx 1.3 A 站点获取到 token=xxxxx，后台访问 SSO ，验证 token ​ 1.3.1 验证通过，自动登录成功 ​ 1.3.2 验证失败，自动登录失败 ​ " }, { "title": "Innodb中auto_increment处理（官网版）", "url": "/posts/InnoDB%E4%B8%ADauto_increment%E5%A4%84%E7%90%86-%E5%AE%98%E7%BD%91%E7%89%88/", "categories": "MySQL", "tags": "MySQL, InnoDB", "date": "2021-09-15 00:00:00 +0800", "snippet": "《 MySQL 5.7 - InnoDB 中的 AUTO_INCREMENT 处理（个人版）》地址：官网地址 https://dev.mysql.com/doc/refman/5.7/en/innodb-auto-increment-handling.htmlInnoDB 提供了一种可配置的锁机制，通过为新插入的行增加 auto_increment 列，可以显著提高 SQL 语句的可伸缩性和性能。要在 InnoDB 中使用 auto_increment 机制，auto_increment 列必须定义为索引的第一列或者唯一列，以便可以对 table 执行等价于对索引列 select max..." }, { "title": "MySQL 5.7 - InnoDB 中的 AUTO_INCREMENT 处理（个人版）", "url": "/posts/InnoDB%E4%B8%ADauto_increment%E5%A4%84%E7%90%86-(%E4%B8%AA%E4%BA%BA%E7%89%88/", "categories": "MySQL", "tags": "MySQL, InnoDB", "date": "2021-09-15 00:00:00 +0800", "snippet": "《 MySQL 5.7 - InnoDB 中的 AUTO_INCREMENT 处理（官网版）》地址：MySQL 官网地址： https://dev.mysql.com/doc/refman/5.7/en/innodb-auto-increment-handling.htmlauto_increment 三种锁定模式InnoDB 对于 column，提供了 auto_increment （自增）配置，因为性能和扩展性的考虑，自增值有三种不同的模式，通过 MySQL 启动时的 innodb_autoinc_lock_mode 属性指定，该属性有三种取值，分别是0、1、2。可通过以下语句查看：..." }, { "title": "Mysql - 一条 SQL 的执行过程", "url": "/posts/%E4%B8%80%E6%9D%A1SQL%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B/", "categories": "mysql", "tags": "mysql", "date": "2021-09-08 00:00:00 +0800", "snippet": "" }, { "title": "JVM - 值传递", "url": "/posts/JAVA%E5%80%BC%E4%BC%A0%E9%80%92%E8%A7%A3%E6%9E%90/", "categories": "JVM", "tags": "JVM、类型传递", "date": "2021-08-27 00:00:00 +0800", "snippet": "JAVA 是值传递，栈内值的传递堆只是存储空间，栈代表线程执行过程，JAVA 方法参数传递只与栈有关认真看下下方代码，就懂了public class Test { public void fun01() { User user01 = new User(); user01.username = &quot;张三&quot;; fun02(user01); System.out.println(user01); User user02 = new User(); user02.username = &..." }, { "title": "JAVA 基础（一）：线程、锁", "url": "/posts/%E7%BA%BF%E7%A8%8B-%E9%94%81/", "categories": "JAVA", "tags": "JAVA, 线程, 锁", "date": "2021-06-29 00:00:00 +0800", "snippet": "思考两个线程在控制台交替打印 1 到 100这道题看似简单，不过我第一次写不出来，百度了一下，有答案，但不满意，看了下书，果然很有内涵。接下来将循序渐进，先展示创建新线程的方式、再看上面题目的三种解法、再挖掘潜在价值新线程创建方式1. Thread@Testpublic void test001() throws InterruptedException { class ThreadTest extends Thread { @Override public void run() { System.out.println(Threa..." }, { "title": "EnumHandler", "url": "/posts/EnumHandler/", "categories": "JAVA", "tags": "JAVA, Mybatis", "date": "2021-06-28 00:00:00 +0800", "snippet": "地址https://github.com/bichengfei/EnumHandler介绍本项目是对 Mybatis 中枚举类型处理器的增强，新旧项目均可使用有什么用使用 Mybatis 时，对于 Integer 类型字段，不管是作为 parameterType 或是 resultType，Mybatis 都能优雅的处理。原理是 Mybatis 针对 Integer 实现了 Java 数据类型和 Jdbc数据类型之间的转换规则，也就是 IntegerTypeHandler，也可称之为 Integer 类型处理器。Mybatis 已经实现了很丰富的类型处理器，对于枚举类型，也提供了两种处理..." }, { "title": "Git 操作", "url": "/posts/Git-%E6%93%8D%E4%BD%9C/", "categories": "Git", "tags": "Git", "date": "2021-05-20 15:53:00 +0800", "snippet": " 已有分支 old_branch，新建分支 new_branch git checkout old_branchgit checkout -b new_branch(包含两步：git branch new_branch、git checkout new_branch)git push origin new_branchgit branch --set-upstream-to=origin/new_branch new_branch(origin/new_branch: 远程分支，new_branch：本地分支，这一步为了使两个分支产生映射，pull/push 时不用指定分..." }, { "title": "JVM 类加载机制", "url": "/posts/JVM-ClassLoader/", "categories": "JAVA", "tags": "JAVA, JVM", "date": "2021-05-13 15:53:00 +0800", "snippet": "参考： 《深入理解java虚拟机》 –周志明思考几个小问题 这三种都是在什么时候被初始化和赋值，在类加载中有什么不同？ final static int a = 1;static int a = 1;int a = 1; 现在我们有一个项目–Hello，打成jar包，成功部署并正常运行，有一天我们要修改Test01.java(不包含内部类)，打算修改完编译后只把Hello.jar中的Test01.class进行替换，运行，这样是否可以？ Test01.java中有final修饰的常量是否可以？ Test01.java中不..." } ]
